# ہفتہ 3: ROS 2 کے بنیادی اصول

اس ہفتے، ہم روبوٹ آپریٹنگ سسٹم 2 (ROS 2) میں غوطہ لگاتے ہیں، جو روبوٹ سافٹ ویئر لکھنے کے لیے ایک لچکدار فریم ورک ہے۔ ROS 2 اوزار، لائبریریوں، اور کنونشنز کا ایک مجموعہ فراہم کرتا ہے جس کا مقصد پیچیدہ اور مضبوط روبوٹ ایپلی کیشنز بنانے کے کام کو آسان بنانا ہے۔ یہ خاص طور پر تقسیم شدہ نظاموں کے لیے موزوں ہے اور اپنے پیشرو، ROS 1 کے مقابلے میں حقیقی وقت کے کنٹرول، سیکورٹی، اور ملٹی روبوٹ کوآرڈینیشن کے لیے بہتر صلاحیتوں کا حامل ہے۔

## ROS 2 فن تعمیر اور بنیادی تصورات

ROS 2 ایک تقسیم شدہ، غیر مطابقت پذیر، ہم مرتبہ سے ہم مرتبہ مواصلاتی فن تعمیر کے ارد گرد بنایا گیا ہے۔ اس کے بنیادی تصورات میں شامل ہیں:

### نوڈس
ایک **نوڈ** ایک قابل عمل عمل ہے جو ایک مخصوص کام انجام دیتا ہے۔ روبوٹ سسٹم میں، آپ کے پاس موٹرز کو کنٹرول کرنے، سینسر ڈیٹا پڑھنے، لوکلائزیشن انجام دینے، یا ٹریکٹریز کی منصوبہ بندی کے لیے نوڈس ہو سکتے ہیں۔ نوڈس کو ماڈیولر اور دوبارہ قابل استعمال ہونے کے لیے ڈیزائن کیا گیا ہے۔
- **ماڈیولریٹی**: ہر نوڈ ایک اسٹینڈ اسٹون پروگرام ہے، جو ترقی، ڈیبگنگ، اور تعیناتی کو آسان بناتا ہے۔
- **ہم آہنگی**: ایک سے زیادہ نوڈس بیک وقت چل سکتے ہیں، یہاں تک کہ مختلف مشینوں پر بھی، نیٹ ورک پر مواصلت کرتے ہوئے۔

### موضوعات
**موضوعات** ROS 2 میں غیر مطابقت پذیر، کئی سے کئی، پبلش-سبسکرائب مواصلت کے لیے بنیادی طریقہ کار ہیں۔ نوڈس ڈیٹا (پیغامات) کو ایک موضوع پر شائع کرتے ہیں، اور دوسرے نوڈس اس موضوع کو ڈیٹا حاصل کرنے کے لیے سبسکرائب کرتے ہیں۔
- **پیغامات**: ڈیٹا ڈھانچے جو موضوعات لے جاتے ہیں، جو `.msg` فائلوں کا استعمال کرتے ہوئے بیان کیے جاتے ہیں۔ ان میں معیاری اقسام (انٹیجرز، فلوٹس، سٹرنگز) یا پیچیدہ نیسٹڈ ڈھانچے شامل ہو سکتے ہیں۔
- **پبلشرز اور سبسکرائبرز**: نوڈس مخصوص موضوعات پر پبلشرز (پیغامات بھیجنے والے) یا سبسکرائبرز (پیغامات وصول کرنے والے) کے طور پر کام کرتے ہیں۔
- **ڈھیلا جوڑا**: پبلشرز اور سبسکرائبرز کو ایک دوسرے کے بارے میں براہ راست جاننے کی ضرورت نہیں ہوتی ہے۔ انہیں صرف موضوع کے نام اور پیغام کی قسم پر متفق ہونے کی ضرورت ہوتی ہے۔

### خدمات
**خدمات** ایک مطابقت پذیر، درخواست-جواب مواصلاتی طریقہ کار فراہم کرتی ہیں۔ ایک کلائنٹ نوڈ ایک سروس سرور کو درخواست بھیجتا ہے، جو درخواست پر کارروائی کرتا ہے اور جواب واپس بھیجتا ہے۔ خدمات ان کارروائیوں کے لیے موزوں ہیں جن میں واضح آغاز اور اختتام شامل ہوتا ہے، جیسے کسی کارروائی کو متحرک کرنا یا کسی مخصوص معلومات کے ٹکڑے کو استفسار کرنا۔
- **درخواست/جواب**: `.srv` فائلوں کا استعمال کرتے ہوئے بیان کیا گیا ہے، جو درخواست اور جواب دونوں کے لیے ساخت کی وضاحت کرتی ہیں۔
- **کلائنٹ/سرور**: ایک نوڈ کلائنٹ (درخواستیں بھیجنے والا) کے طور پر کام کرتا ہے، اور دوسرا نوڈ سرور (درخواستوں کو سنبھالنے اور جوابات بھیجنے والا) کے طور پر کام کرتا ہے۔

### اعمال
**اعمال** ایک اعلیٰ سطحی مواصلاتی طریقہ کار ہیں جو طویل عرصے تک چلنے والے کاموں کے لیے ڈیزائن کیے گئے ہیں جن میں متواتر فیڈ بیک اور پیشگی منسوخی کی صلاحیت ہوتی ہے۔ وہ موضوعات (فیڈ بیک) اور خدمات (درخواست/جواب کا مقصد) کے پہلوؤں کو یکجا کرتے ہیں۔
- **مقصد، فیڈ بیک، نتیجہ**: ایک ایکشن کلائنٹ ایک ایکشن سرور کو ایک مقصد بھیجتا ہے۔ سرور اپنی پیشرفت پر مسلسل فیڈ بیک فراہم کرتا ہے اور آخر کار حتمی نتیجہ واپس کرتا ہے۔ کلائنٹ مقصد کو بھی منسوخ کر سکتا ہے۔
- **استعمال کے معاملات**: "کسی نقطہ پر تشریف لے جائیں،" "کوئی چیز اٹھائیں،" یا "ایک پیچیدہ حرکت کی ترتیب انجام دیں" جیسے کاموں کے لیے مثالی۔

## `rclpy` کا استعمال کرتے ہوئے پائتھن ایجنٹس کو ROS کنٹرولرز سے جوڑنا

`rclpy` ROS 2 کے لیے پائتھن کلائنٹ لائبریری ہے، جو تمام ROS 2 بنیادی فعالیتوں کے لیے ایک محاوراتی پائتھن انٹرفیس فراہم کرتی ہے۔ یہ ڈویلپرز کو پائتھن کا استعمال کرتے ہوئے نوڈس، پبلشرز، سبسکرائبرز، سروس کلائنٹس، اور سروس سرورز لکھنے کی اجازت دیتا ہے۔ یہ خاص طور پر اے آئی الگورتھم (اکثر پائتھن میں تیار کردہ) کو روبوٹ ہارڈ ویئر کنٹرولرز کے ساتھ مربوط کرنے کے لیے اہم ہے۔

`rclpy` کے اہم پہلو:
- **کم سے کم API**: ہلکا پھلکا اور موثر ہونے کے لیے ڈیزائن کیا گیا ہے، جو ضروری ROS 2 پرائمیٹیوز کو ظاہر کرتا ہے۔
- **غیر مطابقت پذیر پروگرامنگ**: پائتھن کے `asyncio` کے ساتھ غیر مسدود کارروائیوں کے لیے اچھی طرح سے مربوط ہوتا ہے، جو حقیقی وقت کے روبوٹ کنٹرول کے لیے اہم ہے۔
- **پیغام کی تخلیق**: `.msg` اور `.srv` فائلوں سے خود بخود پائتھن کلاسز تیار کرتا ہے، جس سے کسٹم ڈیٹا کی اقسام کی وضاحت اور استعمال آسان ہوجاتا ہے۔

**مثال**: ایک پائتھن پر مبنی اے آئی ایجنٹ `rclpy` کا استعمال کر سکتا ہے:
1. ادراک کے لیے سینسر ڈیٹا کے موضوعات کو سبسکرائب کرنا (جیسے، کیمرے کی تصاویر، LiDAR اسکین)۔
2. روبوٹ کنٹرولرز کو کمانڈ پیغامات (جیسے، موٹر کی رفتار، جوائنٹ پوزیشنز) شائع کرنا۔
3. مخصوص روبوٹ کے طرز عمل کو متحرک کرنے کے لیے خدمات کو کال کرنا (جیسے، ایک گریپر کو چالو کرنا)۔
4. نیویگیشن یا پیچیدہ ہیرا پھیری کے کاموں کے لیے ایکشن سرورز کے ساتھ تعامل کرنا۔

## ہیومنائیڈز کے لیے URDF (یونیفائیڈ روبوٹ ڈسکریپشن فارمیٹ) کو سمجھنا

**یونیفائیڈ روبوٹ ڈسکریپشن فارمیٹ (URDF)** ایک XML فارمیٹ ہے جو ROS میں روبوٹ کے تمام عناصر کو بیان کرنے کے لیے استعمال ہوتا ہے۔ یہ نقالی، تصور، اور ہیرا پھیری کی منصوبہ بندی کے لیے بہت اہم ہے۔

URDF کے اہم عناصر:
- **لنکس**: روبوٹ کے سخت جسموں کی نمائندگی کرتے ہیں (جیسے، دھڑ، اوپری بازو، ہاتھ)۔ ہر لنک کے ساتھ بصری (میش فائلیں، رنگ)، جڑی (کمیت، جڑی میٹرکس)، اور تصادم کی خصوصیات وابستہ ہوتی ہیں۔
- **جوائنٹس**: لنکس کے درمیان رابطوں کو بیان کرتے ہیں، ان کی قسم (ریوولیوٹ، پرزمیٹک، فکسڈ)، حرکت کا محور، حدود، اور حرکیات کی وضاحت کرتے ہیں۔
- **کائیمیٹکس**: URDF واضح طور پر روبوٹ کی کائیمیٹک چین (لنکس اور جوائنٹس کیسے جڑے ہوئے ہیں) کی وضاحت کرتا ہے، جسے ROS 2 پیکجز فارورڈ اور انورس کائیمیٹکس کے حسابات کے لیے استعمال کرتے ہیں۔
- **ایکسٹینشنز**: URDF کو دیگر فارمیٹس جیسے XACRO (XML میکروز) کے ساتھ ماڈیولریٹی اور پیچیدہ روبوٹس کی آسان تفصیل کے لیے، یا SDF (سمیولیشن ڈسکریپشن فارمیٹ) کے ساتھ Gazebo میں بھرپور نقالی خصوصیات کے لیے بڑھایا جا سکتا ہے۔

ہیومنائیڈ روبوٹس کے لیے، ایک تفصیلی اور درست URDF ضروری ہے۔ یہ قابل بناتا ہے:
- **تصور**: RViz جیسے اوزار میں روبوٹ کا 3D ماڈل دکھانا۔
- **نقالی**: روبوٹ کو Gazebo جیسے فزکس سمیلیٹرز میں لوڈ کرنا۔
- **حرکت کی منصوبہ بندی**: روبوٹ کے اعضاء کے لیے تصادم سے پاک ٹریکٹریز تیار کرنا۔
- **کنٹرول**: نچلی سطح کے کنٹرولرز کے لیے جوائنٹ کی حدود اور حرکیات کی وضاحت کرنا۔

اس ہفتے کی توجہ روبوٹس کے ساتھ بنیادی سطح پر تعامل کے لیے ضروری ٹول کٹ فراہم کرتی ہے، جو نقالی اور اے آئی انضمام میں مزید جدید موضوعات کے لیے مرحلہ طے کرتی ہے۔
